using System;
using System.Collections.Generic;

namespace conilines.engine
{
    /// <summary>
    /// Token`s id, value and coordinates in one struct
    /// </summary>
    public struct GameTokenData
    {
        /// <summary>
        /// column
        /// </summary>
        public int x;
        /// <summary>
        /// row
        /// </summary>
        public int y;
        /// <summary>
        /// Field[x,y].id
        /// </summary>
        public int id;
        /// <summary>
        /// Field[x,y].Value
        /// </summary>
        public int value;

        internal GameTokenData(ItemData itd) : this()
        {
            x = itd.x;
            y = itd.y;
            id = itd.Token.ID;
            value = itd.Token.Value;
        }

        internal GameTokenData(int x, int y, GameToken t) : this()
        {
            this.x = x;
            this.y = y;
            id = t.ID;
            value = t.Value;
        }
    }

    /// <summary>
    /// Argument For events generated by token
    /// </summary>
    public class TokenEventArgs : EventArgs
    {
        /// <summary>
        /// Tokens whis message applies to
        /// </summary>
        public List<GameTokenData> Tokens;
        /// <summary>
        /// Constructor only initialize internal fields. Values should be set separately
        /// </summary>
        public TokenEventArgs()
        {
            Tokens = new List<GameTokenData>();
        }
    }
    /// <summary>
    /// Controls tokens, calculate solutions
    /// </summary>
    public class GameField
    {
        /// <summary>
        /// New token(s) added to a field
        /// </summary>
        public event EventHandler<TokenEventArgs> TokensAdded;
        /// <summary>
        /// Some tokens removed from field
        /// </summary>
        public event EventHandler<TokenEventArgs> TokensKilled;
        /// <summary>
        /// Any change of field
        /// </summary>
        public event EventHandler<TokenEventArgs> FieldChanged;

        private readonly int minLine = 3;
        private GameToken[,] Data;
        /// <summary>
        /// Value of token with given coordinates on field
        /// </summary>
        /// <param name="x">row</param>
        /// <param name="y">column</param>
        /// <returns>Value of token</returns>
        public GameToken this[int x, int y]
        {
            get { return Data[x, y]; }
        }

        private int sizeL;
        private int sizeH;
        /// <summary>
        /// "Gravitation" direction - where tokens will slide when added or when hole occures on a field
        /// </summary>
        public Directions SlideDirection { get; set; }

        private readonly int Seed;
        /// <summary>
        /// Length of field i.e. number of columns
        /// </summary>
        public int FieldLength => sizeL;
        /// <summary>
        /// Height of field i/e nnumber of rows
        /// </summary>
        public int FieldHeight => sizeH;
        Random rnd;
        private int TotalTokens;

        private int NextSeed
        {
            get
            {
                return rnd.Next(1, TheGame.maxIndex);
            }
        }
        ///<summary>Check if all cells on field are occupied</summary>
        public bool Complete { get { return (TotalTokens == sizeL * sizeH); } }

        ///<summary>Creates new Rectangular field </summary>
        ///<param name = "sizeL" >Field Length</param>
        ///<param name = "sizeH" >Field Height</param>
        ///<param name = "seed" >Seed for random generator for initial fill</param>
        public GameField(int sizeL = 10, int sizeH = 10, int seed = 0)
        {
            this.sizeL = sizeL;
            this.sizeH = sizeH;
            Data = new GameToken[sizeL, sizeH];
            Seed = seed;
            SlideDirection = TheGame.Direction;
            InitField();
        }
        /// <summary>
        /// Fill field with random tokens without solutions
        /// </summary>
        public void InitField()
        {
            rnd = new Random(Seed);

            for (int x = 0; x < sizeL; x++)
                for (int y = 0; y < sizeH; y++)
                    Data[x, y] = new GameToken(rnd.Next(1, TheGame.maxIndex));
            TotalTokens = sizeH * sizeL;
            Fill(true);
        }

        /// <summary>
        /// Length and heighrt of field
        /// </summary>
        /// <returns>Field dimensions as a string</returns>
        public override string ToString()
        {
            return string.Format("Array:{0}x{1}", sizeL, sizeH);
        }
        private static int CompareBySum(ItemData x, ItemData y)
        {
            int diff = (x.x + x.y - y.x - y.y);
            return Math.Sign(diff);
        }
        /// <summary>
        /// Solve field and kill solution tokens
        /// </summary>
        /// <param name="FindAndKill">sohuld solution tokens be killed</param>
        /// <returns>true if field solved</returns>
        public bool GetLines(bool FindAndKill = true)
        {
            List<ItemData> Cluster = new List<ItemData>();
            Queue<ItemData> Candidate = new Queue<ItemData>();
            List<ItemData> Everything = new List<ItemData>();

            int y = -1;
            int x = 0;
            bool linefound = false;
            int xmax = 0;
            int xlen = 0;
            int xmaxstart = 0;
            int xlenstart = 0;

            while ((++y < FieldHeight) && !linefound) // scan rows
            {
                x = 0;
                xlen = 0;
                while (++x < sizeL)
                {
                    if (Data[x, y].Alive && Data[x - 1, y].Alive)
                    {
                        if (Data[x, y].Value == Data[x - 1, y].Value)
                        {
                            if (xlen == 0)
                            {
                                xlenstart = x - 1;
                                xlen++;
                            }
                            xlen++;
                        }else
                            xlen = 0;

                        if (xmax < xlen)
                        {
                            xmax = xlen;
                            xmaxstart = xlenstart;
                        }
                        

                        if (xmax >= minLine)
                            linefound = true;
                    }
                }
            }

            if (linefound)
            {
                for (int ix = xmaxstart; ix < xmaxstart + xmax; ix++)
                    Cluster.Add(new ItemData() { x = ix, y = y - 1, check = false, Token = Data[ix, y - 1] });

                BuildCluster(Cluster, x: xmaxstart, y: y - 1);

                if (CheckCluster(FindAndKill, Cluster))
                    return true;
            }

            x = -1;
            while ((++x < FieldLength) && !linefound) // scan columns
            {
                y = 0;
                xlen = 0;
                while (++y < sizeH)
                {
                    if (Data[x, y].Alive && Data[x, y-1].Alive)
                    {
                        if (Data[x, y].Value == Data[x, y-1].Value)
                        {
                            if (xlen == 0)
                            {
                                xlenstart = y - 1;
                                xlen++;
                            }
                            xlen++;
                        }
                        else
                            xlen = 0;

                        if (xmax < xlen)
                        {
                            xmax = xlen;
                            xmaxstart = xlenstart;
                        }
                        if (xmax >= minLine)
                            linefound = true;
                    }
                }
            }

            if (linefound)
            {
                for (int iy = xmaxstart; iy < xmaxstart + xmax; iy++)
                    Cluster.Add(new ItemData() { x = x - 1, y = iy, check = false, Token = Data[x - 1, iy] });

                BuildCluster(Cluster, x: x - 1, y: xmaxstart);
                if (CheckCluster(FindAndKill, Cluster))
                    return true;
            }

            return false;
        }

        // used in GetLines
        private bool CheckCluster(bool FindAndKill, List<ItemData> Cluster)
        {
            TokenEventArgs ea = new TokenEventArgs();
            if (Cluster.Count > 0)
            {
                if (FindAndKill)
                {
                    foreach (ItemData itd in Cluster)
                    {
                        Data[itd.x, itd.y].Kill();
                        TotalTokens--;
                        ea.Tokens.Add(new GameTokenData(itd));
                    }
                    OnTokensKilled(ea);
                }
                return true;
            }
            return false;
        }

        // Grow cluster in all directions, adding tokens with same value
        private void BuildCluster(List<ItemData> Cluster, int x, int y)
        {
            int clusterValue = Data[x, y].Value;
            bool keepup = true;
            int maxcluster = 40;
            while (keepup)
            {
                keepup = false;
                for (int cIndex = 0; cIndex < Cluster.Count; cIndex++)
                {
                    ItemData itd = Cluster[cIndex];
                    if (itd.check) continue;

                    keepup = CheckToken(Cluster, itd.x - 1, itd.y, clusterValue, keepup);
                    keepup = CheckToken(Cluster, itd.x + 1, itd.y, clusterValue, keepup);
                    keepup = CheckToken(Cluster, itd.x, itd.y - 1, clusterValue, keepup);
                    keepup = CheckToken(Cluster, itd.x, itd.y + 1, clusterValue, keepup);

                    itd.check = true;
                    Cluster[cIndex] = itd;
                }
                keepup = keepup && (maxcluster <= Cluster.Count);
            }
            if (maxcluster <= Cluster.Count)
                Cluster.Clear();
        }
        // used in BuildCluster: check token on coords dx, dy and add to cluseter
        private bool CheckToken(List<ItemData> Cluster, int dx, int dy, int clusterValue, bool keepup)
        {
            if (InRange( dx,  dy))
                if (Data[ dx,  dy].Value == clusterValue)
                {
                    bool test = TestAddCluster(Cluster,
                        new ItemData() { x =  dx, y = dy, check = false, Token = Data[ dx,  dy] }
                        );
                    keepup = keepup || test;
                }

            return keepup;
        }
        // add ItemData to cluster , if it's not already there
        private bool TestAddCluster(List<ItemData> Cluster, ItemData itd)
        {
            if (InRange(itd.x, itd.y))
                if (Cluster.FindIndex(t => t.x == itd.x && t.y == itd.y) == -1)
                {
                    Cluster.Add(itd);
                    return true;
                }
            return false;
        }
        
        /// <summary>
        /// Token "Next" to given coordinates with current  slide direction
        /// if no such token - return null
        /// </summary>
        /// <param name="x">row number</param>
        /// <param name="y">column nubmer</param>
        /// <returns>following token or null</returns>
        internal GameToken NextToken(int x, int y)
        {
            switch (SlideDirection)
            {
                case Directions.Up:
                    if (InRange(x, y + 1))
                        return Data[x, y + 1];
                    break;
                case Directions.Down:
                    if (InRange(x, y - 1))
                        return Data[x, y - 1];
                    break;
                case Directions.Left:
                    if (InRange(x - 1, y))
                        return Data[x - 1, y];
                    break;
                case Directions.Right:
                    if (InRange(x + 1, y))
                        return Data[x + 1, y];
                    break;
            }
            return null;
        }
        
        /// <summary>
        /// move tokens to current slide direction to fill holes on a field
        /// </summary>
        /// <returns></returns>
        public bool Slide()
        {
            int dx = 0;
            int dy = 0;
            switch (SlideDirection)
            {
                case Directions.Left: dx = -1; break;
                case Directions.Right: dx = 1; break;
                case Directions.Up: dy = 1; break;
                case Directions.Down: dy = -1; break;
            }
            bool reslide;
            bool result = false;
            do
            {
                reslide = false;
                for (int x = 0; x < FieldLength; x++)
                    for (int y = 0; y < sizeH; y++)
                    {
                        if (InRange(x + dx, y + dy))
                            if (Data[x, y].Alive)
                                if (!Data[x + dx, y + dy].Alive)
                                {
                                    Swap(x, y, x + dx, y + dy);
                                    reslide = true;
                                    result = true;
                                }
                    }
            } while (reslide);
            if (result)
            {
                TokenEventArgs ea = new TokenEventArgs();
                OnFieldChanged(ea);
            }
            return result;
        }

        private void AddToken(int x, int y, TokenEventArgs ea)
        {
            Data[x, y] = new GameToken(NextSeed);
            ea.Tokens.Add(new GameTokenData(x, y, Data[x, y]));
            TotalTokens++;
        }
        /// <summary>
        /// Fill holes on a field with random tokens
        /// </summary>
        /// <param name="nolines">ensure filled tokens never result a ready solution</param>
        public void Fill(bool nolines = false)
        {
            TokenEventArgs ea = new TokenEventArgs();

            bool loop = false;
            do
            {
                loop = false;
                for (int x = 0; x < sizeL; x++)
                    for (int y = 0; y < sizeH; y++)
                    {
                        if (InRange(x, y))
                            if (!Data[x, y].Alive)
                            {
                                //GameToken t = ;
                                Data[x, y] = new GameToken(NextSeed);
                                ea.Tokens.Add(new GameTokenData(x, y, Data[x, y]));
                                TotalTokens++;
                            }
                    }

                while (nolines && GetLines())
                {
                    Slide();
                    loop = true;
                }

            } while (loop);
            if (ea.Tokens.Count > 0)
                OnTokensAdded(ea);
        }

        /// <summary>
        /// Fill holes on a field with random tokens, according to slide direction
        /// </summary>
        /// <param name="nolines"></param>
        public void FillOneLine(bool nolines = false)
        {
            TokenEventArgs ea = new TokenEventArgs();

            switch (SlideDirection)
            {
                case Directions.Up:

                    for (int x = 0; x < sizeH; x++)
                    {
                        int y = sizeH - 1;
                        while ((y >= 0) && (Data[x, y].Alive)) y--;
                        if (y >= 0)
                        {
                            AddToken(x, y, ea);
                        }
                    }
                    break;
                case Directions.Down:
                    for (int x = 0; x < sizeH; x++)
                    {
                        int y = 0;
                        while ((y < sizeH) && (Data[x, y].Alive)) y++;
                        if (y < sizeH)
                        {
                            AddToken(x, y, ea);
                        }
                    }
                    break;
                case Directions.Right:
                    for (int y = 0; y < sizeH; y++)
                    {
                        int x = sizeH - 1;
                        while ((x >= 0) && (Data[x, y].Alive)) x--;
                        if (x >= 0)
                        {
                            AddToken(x, y, ea);
                        }
                    }
                    break;
                case Directions.Left:
                    for (int y = 0; y < sizeH; y++)
                    {
                        int x = 0;
                        while ((x < sizeH) && (Data[x, y].Alive)) x++;
                        if (x < sizeL)
                        {
                            AddToken(x, y, ea);
                        }
                    }
                    break;
            }
            if (ea.Tokens.Count > 0)
                OnTokensAdded(ea);
            else
                TotalTokens = sizeH * sizeL;
        }

        /// <summary>
        /// swap tokens on (x, y) and (dx, dy)
        /// </summary>
        private void Swap(int x, int y, int dx, int dy)
        {
            GameToken tmp = Data[x, y];
            Data[x, y] = Data[dx, dy];
            Data[dx, dy] = tmp;
        }

        /// <summary>
        /// swap token with given id and its neighbour in given direction
        /// </summary>
        /// <param name="id">id of given token</param>
        /// <param name="where">direction to swap token</param>
        public void SwapTokens(int id, Directions where)
        {
            int[] cx = Coordinates(id);
            int x = cx[0];
            int y = cx[1];

            if (InRange(x, y))
                if (Data[x, y].ID == id)
                {
                    switch (where)
                    {
                        case Directions.Up:
                            Swap(x, y, x, y + 1);
                            break;
                        case Directions.Down:
                            Swap(x, y, x, y - 1);
                            break;
                        case Directions.Left:
                            Swap(x, y, x - 1, y);
                            break;
                        case Directions.Right:
                            Swap(x, y, x + 1, y);
                            break;
                    }
                }
        }

        // check if coordinates inside field
        private bool InRange(int v1, int v2)
        {
            return (v1 >= 0) && (v1 < sizeL) && (v2 >= 0) && (v2 < sizeH);
        }

        /// <summary>
        /// find coordinates of token with id
        /// as array res[0] = x, res[1] = y
        /// </summary>
        /// <param name="id"></param>
        /// <returns>{x,y}</returns>
        public int[] Coordinates(int id)
        {
            int x = -1;
            int y = 0;
            int[] res = new int[2];
            res[0] = -1;
            res[1] = -1;
            while (++x < FieldLength)
            {
                y = -1;
                while (++y < FieldHeight)
                {
                    if (Data[x, y].ID == id)
                    {
                        res[0] = x;
                        res[1] = y;
                        x = FieldLength + 1;
                        y = FieldHeight + 1;
                    }
                }
            }
            return res;
        }

        /// <summary>
        /// check if field have token with id
        /// </summary>
        /// <param name="id"></param>
        /// <returns>true if field have token tiwh id, false otherwise</returns>
        public bool HaveID(int id)
        {
            foreach (GameToken t in Data)
                if (t.ID == id) return true;

            return false;
        }

        /// <summary>
        /// OnTokensAdded event starter
        /// </summary>
        /// <param name="e"></param>
        protected virtual void OnTokensAdded(TokenEventArgs e)
        {
            EventHandler<TokenEventArgs> handler = TokensAdded;
            handler?.Invoke(this, e);
        }

        /// <summary>
        /// OnTokensKilled event starter
        /// </summary>
        /// <param name="e"></param>
        protected virtual void OnTokensKilled(TokenEventArgs e)
        {
            EventHandler<TokenEventArgs> handler = TokensKilled;
            handler?.Invoke(this, e);
        }

        /// <summary>
        /// OnFieldChanged event starter
        /// </summary>
        /// <param name="e"></param>
        protected virtual void OnFieldChanged(TokenEventArgs e)
        {
            EventHandler<TokenEventArgs> handler = FieldChanged;
            handler?.Invoke(this, e);
        }


    }
}